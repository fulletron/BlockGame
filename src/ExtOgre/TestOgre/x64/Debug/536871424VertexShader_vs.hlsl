#if 0
	***	hlms_shadowmap4_uv_min_x_int	0
	***	hlms_uv_count0	2
	***	uv_emissive	0
	***	first_valid_detail_map_nm	4
	***	fresnel_scalar	0
	***	hlms_shadowmap4_uv_max_y_int	1
	***	hlms_uv_count	1
	***	pcf_iterations	9
	***	hlms_shadowmap4_uv_max_y_fract	0
	***	uv_detail_nm1	0
	***	hlms_lights_spotparams	2
	***	hlms_forwardplus_debug	0
	***	uv_detail_nm2	0
	***	hlms_tex_gather	1
	***	BRDF_Default	1
	***	hlms_shadowmap2_array_idx	0
	***	hlms_shadowmap3_uv_max_x_fract	0
	***	uv_specular	0
	***	hlms_shadowmap1_uv_min_x_fract	0
	***	PsoBlendblock	0
	***	hlms_shadowmap2_uv_min_x_fract	50000
	***	forward_clustered	599612461
	***	fast_shader_build_hack	1
	***	glsl	635204550
	***	hlms_shadowmap2_uv_max_y_fract	42857
	***	hlms_shadowmap0_uv_max_x_fract	0
	***	hlms_shadowmap2_uv_max_y_int	0
	***	hlms_high_quality	0
	***	hlms_num_shadow_map_lights	5
	***	hlms_lights_directional	1
	***	hlms_shadowmap0_uv_min_y_fract	0
	***	PsoMacroblock	0
	***	hlms_shadowmap1_uv_min_y_fract	28571
	***	alpha_test	0
	***	GGX_height_correlated	1
	***	hlms_shadowmap2	0
	***	glsles	1070293233
	***	metallic_workflow	0
	***	hlms_shadowmap4	0
	***	hw_gamma_write	1
	***	hlms_shadowmap0_uv_min_y_int	0
	***	uv_detail_weight	0
	***	hlms_shadowmap0_uv_max_x_int	1
	***	pcf_4x4	1
	***	hlms_shadowmap4_array_idx	0
	***	hlms_shadowmap1_uvs_fulltex	1
	***	hlms_shadowmap1_uv_max_y_fract	42857
	***	uv_detail_nm3	0
	***	hlms_shadowmap2_uv_max_x_int	1
	***	hlms_pssm_splits	3
	***	signed_int_textures	1
	***	hlms_shadowmap0_uv_min_x_int	0
	***	hlms_shadowmap0_uv_min_x_fract	0
	***	hlms_lights_spot	3
	***	shadowmap2_is_directional_light	1
	***	hlms_shadowmap3_array_idx	0
	***	uv_normal	0
	***	hlms_alphablend	0
	***	hlms_num_shadow_map_textures	1
	***	hlms_shadowmap1_array_idx	0
	***	hlms_shadowmap4_uvs_fulltex	1
	***	num_textures	0
	***	hlms_shadowmap1_uv_min_x_int	0
	***	uv_detail3	0
	***	orwardplus_covers_entire_target	1
	***	hlms_shadow_uses_depth_texture	1
	***	normal_map	0
	***	hlms_shadowmap1	0
	***	hlms_shadowmap2_uv_max_x_fract	0
	***	uv_detail1	0
	***	fresnel_workflow	0
	***	hlms_shadowmap2_uv_min_y_fract	28571
	***	shadowmap1_is_directional_light	1
	***	hlms_shadowmap4_uv_max_x_fract	0
	***	forward3d_num_slices	5
	***	hlms_forwardplus	-1972038953
	***	materials_per_buffer	2
	***	hw_gamma_read	1
	***	hlms_skeleton	0
	***	hlms_shadowmap1_uv_max_y_int	0
	***	hlms_shadowmap3_uv_min_y_int	0
	***	forward3d	-1972038953
	***	hlms_shadowmap2_uv_min_x_int	0
	***	hlms_shadowmap1_uv_max_x_int	0
	***	syntax	-334286542
	***	hlms_lights_point	1
	***	hlms_shadowmap3_uv_max_x_int	1
	***	metal	-1698855755
	***	s_lights_directional_non_caster	1
	***	hlms_shadowmap4_uv_min_x_fract	0
	***	uv_detail0	0
	***	uv_diffuse	0
	***	hlms_pssm_blend	1
	***	uv_detail_nm0	0
	***	hlms_shadowmap3_uv_max_y_int	0
	***	hlms_shadowmap4_uv_min_y_int	0
	***	hlms_lights_attenuation	2
	***	hlms_shadowmap4_uv_min_y_fract	71428
	***	shadowmap0_is_directional_light	1
	***	hlms_shadowmap4_uv_max_x_int	1
	***	hlms_shadowmap0_array_idx	0
	***	hlms_render_depth_only	0
	***	hlms_shadowmap3_uv_min_x_fract	0
	***	uv_detail2	0
	***	hlms_shadowmap3_uv_min_x_int	0
	***	hlms_shadowmap1_uv_max_x_fract	50000
	***	hlms_shadowmap0_uvs_fulltex	1
	***	hlms_qtangent	1
	***	hlms_shadowmap1_uv_min_y_int	0
	***	uv_roughness	0
	***	hlms_shadowmap3_uvs_fulltex	1
	***	receive_shadows	1
	***	hlms_shadowmap3_uv_min_y_fract	42857
	***	hlms_pssm_fade	1
	***	_forward_fade_attenuation_range	1
	***	hlms_shadowmap0	0
	***	hlms_shadowmap3	0
	***	hlms_shadowmap2_uvs_fulltex	1
	***	hlms_shadowmap2_uv_min_y_int	0
	***	ambient_hemisphere	1
	***	hlms_shadowmap0_uv_max_y_fract	28571
	***	hlsl	-334286542
	***	hlms_shadowmap0_uv_max_y_int	0
	***	hlms_shadowmap3_uv_max_y_fract	71428
	***	normal_weight	0
	***	hlms_vpos	1
	DONE DUMPING PROPERTIES
	DONE DUMPING PIECES
#endif

#define INLINE
#define outVs_Position outVs.gl_Position
#define OGRE_SampleLevel( tex, sampler, uv, lod ) tex.SampleLevel( sampler, uv.xy, lod )



float4x4 UNPACK_MAT4( Buffer<float4> matrixBuf, uint pixelIdx )
{
	float4 row1 = matrixBuf.Load( int((pixelIdx) << 2u) );
	float4 row2 = matrixBuf.Load( int(((pixelIdx) << 2u) + 1u) );
	float4 row3 = matrixBuf.Load( int(((pixelIdx) << 2u) + 2u) );
	float4 row4 = matrixBuf.Load( int(((pixelIdx) << 2u) + 3u) );

	return transpose( float4x4( row1, row2, row3, row4 ) );
}


float4x3 UNPACK_MAT4x3( Buffer<float4> matrixBuf, uint pixelIdx )
{
	float4 row1 = matrixBuf.Load( int((pixelIdx) << 2u) );
	float4 row2 = matrixBuf.Load( int(((pixelIdx) << 2u) + 1u) );
	float4 row3 = matrixBuf.Load( int(((pixelIdx) << 2u) + 2u) );

	return transpose( float3x4( row1, row2, row3 ) );
}


struct VS_INPUT
{
	float4 vertex : POSITION;

	float4 qtangent : NORMAL;






	float2 uv0 : TEXCOORD0;
	uint drawId : DRAWID;
	
};

struct PS_INPUT
{

    
		
			nointerpolation uint drawId	: TEXCOORD0;
				
			float3 pos	: TEXCOORD1;
			float3 normal	: TEXCOORD2;
							
			float2 uv0	: TEXCOORD3;
		
			
				float4 posL0	: TEXCOORD4;
			
				float4 posL1	: TEXCOORD5;
			
				float4 posL2	: TEXCOORD6;
			
				float4 posL3	: TEXCOORD7;
			
				float4 posL4	: TEXCOORD8;			
		float depth	: TEXCOORD9;
				
	
	

	float4 gl_Position: SV_Position;

};

// START UNIFORM DECLARATION

struct ShadowReceiverData
{
	float4x4 texViewProj;
	float2 shadowDepthRange;
	float2 padding;
	float4 invShadowMapSize;
};

struct Light
{
	float4 position; //.w contains the objLightMask
	float3 diffuse;
	float3 specular;

	float3 attenuation;
	float3 spotDirection;
	float3 spotParams;
};



//Uniforms that change per pass
cbuffer PassBuffer : register(b0)
{
	struct PassData
	{
	//Vertex shader (common to both receiver and casters)
	float4x4 viewProj;




	//Vertex shader
	float4x4 view;
	ShadowReceiverData shadowRcv[5];
	//-------------------------------------------------------------------------

	//Pixel shader
	float3x3 invViewMatCubemap;
	float padding; //Compatibility with GLSL.

	

	float4 ambientUpperHemi;

	float4 ambientLowerHemi;
	float4 ambientHemisphereDir;

	float pssmSplitPoints0;
	float pssmSplitPoints1;
	float pssmSplitPoints2;
	float pssmBlendPoints0;
	float pssmBlendPoints1;
	float pssmFadePoint;	Light lights[3];

	//Forward3D
	//f3dData.x = minDistance;
	//f3dData.y = invMaxDistance;
	//f3dData.z = f3dNumSlicesSub1;
	//f3dData.w = uint cellsPerTableOnGrid0 (floatBitsToUint);

	//Clustered Forward:
	//f3dData.x = minDistance;
	//f3dData.y = invExponentK;
	//f3dData.z = f3dNumSlicesSub1;
	//f3dData.w = renderWindow->getHeight();
	float4 f3dData;
	
		float4 f3dGridHWW[5];
		float4 f3dViewportOffset;
		
	


	
	} passBuf;
};


Buffer<float4> worldMatBuf : register(t0);

// END UNIFORM DECLARATION



float3 xAxis( float4 qQuat )
{
	float fTy  = 2.0 * qQuat.y;
	float fTz  = 2.0 * qQuat.z;
	float fTwy = fTy * qQuat.w;
	float fTwz = fTz * qQuat.w;
	float fTxy = fTy * qQuat.x;
	float fTxz = fTz * qQuat.x;
	float fTyy = fTy * qQuat.y;
	float fTzz = fTz * qQuat.z;

	return float3( 1.0-(fTyy+fTzz), fTxy+fTwz, fTxz-fTwy );
}










 //SkeletonTransform // !hlms_skeleton


    






PS_INPUT main( VS_INPUT input )
{
	PS_INPUT outVs;
	

	float4x3 worldMat = UNPACK_MAT4x3( worldMatBuf, input.drawId << 1u);
	
    float4x4 worldView = UNPACK_MAT4( worldMatBuf, (input.drawId << 1u) + 1u );
	

	float4 worldPos = float4( mul( input.vertex, worldMat ).xyz, 1.0f );



	//Decode qTangent to TBN with reflection
	float3 normal	= xAxis( normalize( input.qtangent ) );
	


	
	
	//Lighting is in view space
	outVs.pos		= mul( input.vertex, worldView ).xyz;
	outVs.normal	= mul( normal, (float3x3)worldView );
	

	outVs.gl_Position = mul( worldPos, passBuf.viewProj );



	
		
			
				outVs.posL0 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[0].texViewProj );
			
				outVs.posL1 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[1].texViewProj );
			
				outVs.posL2 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[2].texViewProj );
			
				outVs.posL3 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[3].texViewProj );
			
				outVs.posL4 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[4].texViewProj );
		
			
													
			
													
			
													
			
				
					outVs.posL3.z = outVs.posL3.z * passBuf.shadowRcv[3].shadowDepthRange.y;
													
			
				
					outVs.posL4.z = outVs.posL4.z * passBuf.shadowRcv[4].shadowDepthRange.y;
													
		outVs.depth = outVs_Position.z;	
	

	/// hlms_uv_count will be 0 on shadow caster passes w/out alpha test

	outVs.uv0 = input.uv0;


	outVs.drawId = input.drawId;

	



	

	return outVs;
}
