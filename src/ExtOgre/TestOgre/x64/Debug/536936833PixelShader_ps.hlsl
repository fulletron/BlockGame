#if 0
	***	hlms_shadowmap4_uv_min_x_int	0
	***	hlms_uv_count0	2
	***	uv_emissive	0
	***	first_valid_detail_map_nm	4
	***	fresnel_scalar	0
	***	hlms_shadowmap4_uv_max_y_int	1
	***	hlms_uv_count	1
	***	pcf_iterations	9
	***	hlms_shadowmap4_uv_max_y_fract	0
	***	uv_detail_nm1	0
	***	hlms_lights_spotparams	2
	***	hlms_forwardplus_debug	0
	***	uv_detail_nm2	0
	***	hlms_tex_gather	1
	***	BRDF_Default	1
	***	hlms_shadowmap2_array_idx	0
	***	hlms_shadowmap3_uv_max_x_fract	0
	***	uv_specular	0
	***	hlms_shadowmap1_uv_min_x_fract	0
	***	PsoBlendblock	0
	***	hlms_shadowmap2_uv_min_x_fract	50000
	***	hlms_disable_stage	0
	***	texcoord	12
	***	forward_clustered	599612461
	***	fast_shader_build_hack	1
	***	glsl	635204550
	***	hlms_shadowmap2_uv_max_y_fract	42857
	***	hlms_shadowmap0_uv_max_x_fract	0
	***	hlms_shadowmap2_uv_max_y_int	0
	***	hlms_high_quality	0
	***	hlms_num_shadow_map_lights	5
	***	hlms_lights_directional	1
	***	hlms_shadowmap0_uv_min_y_fract	0
	***	PsoMacroblock	0
	***	hlms_shadowmap1_uv_min_y_fract	28571
	***	alpha_test	0
	***	GGX_height_correlated	1
	***	hlms_shadowmap2	0
	***	glsles	1070293233
	***	metallic_workflow	0
	***	hlms_shadowmap4	0
	***	hw_gamma_write	1
	***	hlms_shadowmap0_uv_min_y_int	0
	***	uv_detail_weight	0
	***	roughness_map_idx	2
	***	hlms_shadowmap0_uv_max_x_int	1
	***	pcf_4x4	1
	***	hlms_shadowmap4_array_idx	0
	***	hlms_shadowmap1_uvs_fulltex	1
	***	hlms_shadowmap1_uv_max_y_fract	42857
	***	uv_detail_nm3	0
	***	hlms_shadowmap2_uv_max_x_int	1
	***	hlms_pssm_splits	3
	***	signed_int_textures	1
	***	hlms_shadowmap0_uv_min_x_int	0
	***	hlms_shadowmap0_uv_min_x_fract	0
	***	hlms_lights_spot	3
	***	shadowmap2_is_directional_light	1
	***	hlms_shadowmap3_array_idx	0
	***	uv_normal	0
	***	hlms_alphablend	0
	***	hlms_num_shadow_map_textures	1
	***	hlms_shadowmap1_array_idx	0
	***	hlms_shadowmap4_uvs_fulltex	1
	***	num_textures	3
	***	hlms_shadowmap1_uv_min_x_int	0
	***	normal_map_tex	2
	***	uv_detail3	0
	***	orwardplus_covers_entire_target	1
	***	hlms_shadow_uses_depth_texture	1
	***	normal_map	1
	***	hlms_shadowmap1	0
	***	hlms_shadowmap2_uv_max_x_fract	0
	***	uv_detail1	0
	***	fresnel_workflow	0
	***	hlms_shadowmap2_uv_min_y_fract	28571
	***	shadowmap1_is_directional_light	1
	***	hlms_shadowmap4_uv_max_x_fract	0
	***	forward3d_num_slices	5
	***	hlms_forwardplus	-1972038953
	***	materials_per_buffer	2
	***	hw_gamma_read	1
	***	normal_map_tex_idx	1
	***	hlms_skeleton	0
	***	hlms_shadowmap1_uv_max_y_int	0
	***	hlms_shadowmap3_uv_min_y_int	0
	***	hlms_pssm_splits_minus_one	2
	***	forward3d	-1972038953
	***	hlms_shadowmap2_uv_min_x_int	0
	***	hlms_shadowmap1_uv_max_x_int	0
	***	syntax	-334286542
	***	NeedsMoreThan1BonePerVertex	-1
	***	hlms_lights_point	1
	***	hlms_shadowmap3_uv_max_x_int	1
	***	metal	-1698855755
	***	s_lights_directional_non_caster	1
	***	hlms_shadowmap4_uv_min_x_fract	0
	***	uv_detail0	0
	***	uv_diffuse	0
	***	diffuse_map	1
	***	hlms_pssm_blend	1
	***	uv_detail_nm0	0
	***	hlms_shadowmap3_uv_max_y_int	0
	***	hlms_shadowmap4_uv_min_y_int	0
	***	specular_map	1
	***	diffuse_map_idx	0
	***	hlms_lights_attenuation	2
	***	hlms_shadowmap4_uv_min_y_fract	71428
	***	shadowmap0_is_directional_light	1
	***	hlms_shadowmap4_uv_max_x_int	1
	***	hlms_shadowmap0_array_idx	0
	***	hlms_render_depth_only	0
	***	hlms_shadowmap3_uv_min_x_fract	0
	***	uv_detail2	0
	***	hlms_shadowmap3_uv_min_x_int	0
	***	hlms_shadowmap1_uv_max_x_fract	50000
	***	hlms_shadowmap0_uvs_fulltex	1
	***	hlms_qtangent	1
	***	hlms_shadowmap1_uv_min_y_int	0
	***	uv_roughness	0
	***	hlms_shadowmap3_uvs_fulltex	1
	***	roughness_map	3
	***	receive_shadows	1
	***	hlms_shadowmap3_uv_min_y_fract	42857
	***	hlms_pssm_fade	1
	***	_forward_fade_attenuation_range	1
	***	hlms_shadowmap0	0
	***	hlms_shadowmap3	0
	***	hlms_shadowmap2_uvs_fulltex	1
	***	use_planar_reflections	0
	***	hlms_shadowmap2_uv_min_y_int	0
	***	specular_map_idx	0
	***	ambient_hemisphere	1
	***	hlms_shadowmap0_uv_max_y_fract	28571
	***	hlsl	-334286542
	***	hlms_shadowmap0_uv_max_y_int	0
	***	hlms_shadowmap3_uv_max_y_fract	71428
	***	normal_weight	0
	***	hlms_vpos	1
	DONE DUMPING PROPERTIES
	DONE DUMPING PIECES
#endif

#define INLINE
#define outVs_Position outVs.gl_Position
#define OGRE_SampleLevel( tex, sampler, uv, lod ) tex.SampleLevel( sampler, uv.xy, lod )


	#define UV_DIFFUSE(x) (x)
	#define UV_NORMAL(x) (x)
	#define UV_SPECULAR(x) (x)
	#define UV_ROUGHNESS(x) (x)
	#define UV_DETAIL_WEIGHT(x) (x)
	#define UV_DETAIL0(x) (x)
	#define UV_DETAIL1(x) (x)
	#define UV_DETAIL2(x) (x)
	#define UV_DETAIL3(x) (x)
	#define UV_DETAIL_NM0(x) (x)
	#define UV_DETAIL_NM1(x) (x)
	#define UV_DETAIL_NM2(x) (x)
	#define UV_DETAIL_NM3(x) (x)
	#define UV_EMISSIVE(x) (x)
	


// START UNIFORM DECLARATION

	
		
struct ShadowReceiverData
{
	float4x4 texViewProj;
	float2 shadowDepthRange;
	float2 padding;
	float4 invShadowMapSize;
};

struct Light
{
	float4 position; //.w contains the objLightMask
	float3 diffuse;
	float3 specular;

	float3 attenuation;
	float3 spotDirection;
	float3 spotParams;
};



//Uniforms that change per pass
cbuffer PassBuffer : register(b0)
{
	struct PassData
	{
	//Vertex shader (common to both receiver and casters)
	float4x4 viewProj;




	//Vertex shader
	float4x4 view;
	ShadowReceiverData shadowRcv[5];
	//-------------------------------------------------------------------------

	//Pixel shader
	float3x3 invViewMatCubemap;
	float padding; //Compatibility with GLSL.

	

	float4 ambientUpperHemi;

	float4 ambientLowerHemi;
	float4 ambientHemisphereDir;

	float pssmSplitPoints0;
	float pssmSplitPoints1;
	float pssmSplitPoints2;
	float pssmBlendPoints0;
	float pssmBlendPoints1;
	float pssmFadePoint;	Light lights[3];

	//Forward3D
	//f3dData.x = minDistance;
	//f3dData.y = invMaxDistance;
	//f3dData.z = f3dNumSlicesSub1;
	//f3dData.w = uint cellsPerTableOnGrid0 (floatBitsToUint);

	//Clustered Forward:
	//f3dData.x = minDistance;
	//f3dData.y = invExponentK;
	//f3dData.z = f3dNumSlicesSub1;
	//f3dData.w = renderWindow->getHeight();
	float4 f3dData;
	
		float4 f3dGridHWW[5];
		float4 f3dViewportOffset;
		
	


	
	} passBuf;
};

	
	
//Uniforms that change per Item/Entity, but change very infrequently
struct Material
{
	/* kD is already divided by PI to make it energy conserving.
	  (formula is finalDiffuse = NdotL * surfaceDiffuse / PI)
	*/
	float4 bgDiffuse;
	float4 kD; //kD.w is alpha_test_threshold
	float4 kS; //kS.w is roughness
	//Fresnel coefficient, may be per colour component (float3) or scalar (float)
	//F0.w is transparency
	float4 F0;
	float4 normalWeights;
	float4 cDetailWeights;
	float4 detailOffsetScale[4];
	float4 emissive;		//emissive.w contains mNormalMapWeight.
	float4 reserved[3];

	uint4 indices0_3;
	uint4 indices4_7;

	
};

cbuffer MaterialBuf : register(b1)
{
	Material materialArray[2];
};

	
//Uniforms that change per Item/Entity
cbuffer InstanceBuffer : register(b2)
{
    //.x =
	//The lower 9 bits contain the material's start index.
    //The higher 23 bits contain the world matrix start index.
    //
    //.y =
    //shadowConstantBias. Send the bias directly to avoid an
    //unnecessary indirection during the shadow mapping pass.
    //Must be loaded with uintBitsToFloat
	
		uint4 worldMaterialIdx[2];
	};

	


// END UNIFORM DECLARATION
struct PS_INPUT
{

    
		
			nointerpolation uint drawId	: TEXCOORD0;
				
			float3 pos	: TEXCOORD1;
			float3 normal	: TEXCOORD2;
			float3 tangent	: TEXCOORD3;
				nointerpolation float biNormalReflection	: TEXCOORD4;							
			float2 uv0	: TEXCOORD5;
		
			
				float4 posL0	: TEXCOORD6;
			
				float4 posL1	: TEXCOORD7;
			
				float4 posL2	: TEXCOORD8;
			
				float4 posL3	: TEXCOORD9;
			
				float4 posL4	: TEXCOORD10;			
		float depth	: TEXCOORD11;
				
	
	

};










Buffer<uint> f3dGrid : register(t1);
Buffer<float4> f3dLightList : register(t2);




Texture2DArray textureMaps[3] : register(t4);



	SamplerState samplerState0 : register(s4);
	SamplerState samplerState1 : register(s5);
	SamplerState samplerState2 : register(s6);









float3 getTSNormal( float3 uv )
{
	float3 tsNormal;

	//Normal texture must be in U8V8 or BC5 format!
	tsNormal.xy = textureMaps[1].Sample( samplerState1, uv ).xy;

	tsNormal.z	= sqrt( max( 0, 1.0 - tsNormal.x * tsNormal.x - tsNormal.y * tsNormal.y ) );

	return tsNormal;
}






//Default BRDF
float3 BRDF( float3 lightDir, float3 viewDir, float NdotV, float3 lightDiffuse, float3 lightSpecular, Material material, float3 nNormal , float3 diffuseCol, float3 specularCol, float ROUGHNESS )
{
	float3 halfWay= normalize( lightDir + viewDir );
	float NdotL = saturate( dot( nNormal, lightDir ) );
	float NdotH = saturate( dot( nNormal, halfWay ) );
	float VdotH = saturate( dot( viewDir, halfWay ) );

	float sqR = ROUGHNESS * ROUGHNESS;

	//Roughness/Distribution/NDF term (GGX)
	//Formula:
	//	Where alpha = roughness
	//	R = alpha^2 / [ PI * [ ( NdotH^2 * (alpha^2 - 1) ) + 1 ]^2 ]
	float f = ( NdotH * sqR - NdotH ) * NdotH + 1.0;
	float R = sqR / (f * f + 1e-6f);

	//Geometric/Visibility term (Smith GGX Height-Correlated)

	float Lambda_GGXV = NdotL * sqrt( (-NdotV * sqR + NdotV) * NdotV + sqR );
	float Lambda_GGXL = NdotV * sqrt( (-NdotL * sqR + NdotL) * NdotL + sqR );

	float G = 0.5 / (( Lambda_GGXV + Lambda_GGXL + 1e-6f ) * 3.141592654);


	//Formula:
	//	fresnelS = lerp( (1 - V*H)^5, 1, F0 )
	float fresnelS = material.F0.x + pow( 1.0 - VdotH, 5.0 ) * (1.0 - material.F0.x);

	//We should divide Rs by PI, but it was done inside G for performance
	float3 Rs = ( fresnelS * (R * G) ) * specularCol.xyz * lightSpecular;

	//Diffuse BRDF (*Normalized* Disney, see course_notes_moving_frostbite_to_pbr.pdf
	//"Moving Frostbite to Physically Based Rendering" Sebastien Lagarde & Charles de Rousiers)
	float energyBias	= ROUGHNESS * 0.5;
	float energyFactor	= lerp( 1.0, 1.0 / 1.51, ROUGHNESS );
	float fd90			= energyBias + 2.0 * VdotH * VdotH * ROUGHNESS;
	float lightScatter	= 1.0 + (fd90 - 1.0) * pow( 1.0 - NdotL, 5.0 );
	float viewScatter	= 1.0 + (fd90 - 1.0) * pow( 1.0 - NdotV, 5.0 );


	float fresnelD = 1.0f - fresnelS;

	//We should divide Rd by PI, but it is already included in kD
	float3 Rd = (lightScatter * viewScatter * energyFactor * fresnelD) * diffuseCol.xyz * lightDiffuse;

	return NdotL * (Rs + Rd);
}








	#define hlms_shadowmap0 texShadowMap0
	#define hlms_shadowmap0_uv_min SH_HALF2( 0.0, 0.0 )
	#define hlms_shadowmap0_uv_max SH_HALF2( 1.0, 0.28571 )
	
		
			#define hlms_shadowmap0_uv_param , hlms_shadowmap0_uv_min, hlms_shadowmap0_uv_max
			
	#define hlms_shadowmap1 texShadowMap0
	#define hlms_shadowmap1_uv_min SH_HALF2( 0.0, 0.28571 )
	#define hlms_shadowmap1_uv_max SH_HALF2( 0.50000, 0.42857 )
	
		
			#define hlms_shadowmap1_uv_param , hlms_shadowmap1_uv_min, hlms_shadowmap1_uv_max
			
	#define hlms_shadowmap2 texShadowMap0
	#define hlms_shadowmap2_uv_min SH_HALF2( 0.50000, 0.28571 )
	#define hlms_shadowmap2_uv_max SH_HALF2( 1.0, 0.42857 )
	
		
			#define hlms_shadowmap2_uv_param , hlms_shadowmap2_uv_min, hlms_shadowmap2_uv_max
			
	#define hlms_shadowmap3 texShadowMap0
	#define hlms_shadowmap3_uv_min SH_HALF2( 0.0, 0.42857 )
	#define hlms_shadowmap3_uv_max SH_HALF2( 1.0, 0.71428 )
	
		
			#define hlms_shadowmap3_uv_param , hlms_shadowmap3_uv_min, hlms_shadowmap3_uv_max
			
	#define hlms_shadowmap4 texShadowMap0
	#define hlms_shadowmap4_uv_min SH_HALF2( 0.0, 0.71428 )
	#define hlms_shadowmap4_uv_max SH_HALF2( 1.0, 1.0 )
	
		
			#define hlms_shadowmap4_uv_param , hlms_shadowmap4_uv_min, hlms_shadowmap4_uv_max
			


	#define SH_HALF2 float2
	#define SH_HALF float
	#define OGRE_SAMPLE_SHADOW( tex, sampler, uv, depth ) (depth >= 1.0f ? 1.0 : tex.SampleCmpLevelZero( sampler, uv.xy, depth ).x)
	#define OGRE_SAMPLE_SHADOW_ESM( tex, sampler, uv ) tex.SampleLevel( sampler, uv, 0 ).x
	#define PASSBUF_ARG_DECL
	#define PASSBUF_ARG



		SamplerComparisonState shadowSampler: register(s3);
		
			Texture2D<float> texShadowMap0				: register(t3);	


	
		INLINE float getShadow( Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, 
								float4 psPosLN, float4 invShadowMapSize )
		{
	
		//Spot and directional lights
		float fDepth = psPosLN.z;
		SH_HALF2 uv = SH_HALF2( psPosLN.xy / psPosLN.w );
	
	
		float retVal = 0;

		
			SH_HALF2 offsets[9] =
                        
            {
            						
				SH_HALF2( 0, 0 ),	//0, 0
				SH_HALF2( 1, 0 ),	//1, 0
				SH_HALF2( 1, 0 ),	//2, 0

				SH_HALF2(-2, 1 ),	//0, 1
				SH_HALF2( 1, 0 ),	//1, 1
				SH_HALF2( 1, 0 ),	//2, 1

				SH_HALF2(-2, 1 ),	//0, 2
				SH_HALF2( 1, 0 ),	//1, 2
				SH_HALF2( 1, 0 )	//2, 2
			                        
			};
            		
		
		
			
				uv += offsets[0] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[1] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[2] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[3] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[4] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[5] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[6] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[7] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[8] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );		
		
			retVal *= 0.11111111111111;
			///! exponential_shadow_maps
	   ///! exponential_shadow_maps

	
	
		return retVal;
	}

	
		INLINE float getShadow( Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, 
								float4 psPosLN, float4 invShadowMapSize, SH_HALF2 minUV, SH_HALF2 maxUV )
		{
	
		//Spot and directional lights
		float fDepth = psPosLN.z;
		SH_HALF2 uv = SH_HALF2( psPosLN.xy / psPosLN.w );
	
	
		float retVal = 0;

		
			SH_HALF2 offsets[9] =
                        
            {
            						
				SH_HALF2( 0, 0 ),	//0, 0
				SH_HALF2( 1, 0 ),	//1, 0
				SH_HALF2( 1, 0 ),	//2, 0

				SH_HALF2(-2, 1 ),	//0, 1
				SH_HALF2( 1, 0 ),	//1, 1
				SH_HALF2( 1, 0 ),	//2, 1

				SH_HALF2(-2, 1 ),	//0, 2
				SH_HALF2( 1, 0 ),	//1, 2
				SH_HALF2( 1, 0 )	//2, 2
			                        
			};
            		
		
		
			
				uv += offsets[0] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[1] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[2] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[3] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[4] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[5] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[6] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[7] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[8] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );		
		
			retVal *= 0.11111111111111;
			///! exponential_shadow_maps
	   ///! exponential_shadow_maps

	
	
		retVal = (uv.x <= minUV.x || uv.x >= maxUV.x ||
				  uv.y <= minUV.y || uv.y >= maxUV.y) ? 1.0 : retVal;
	
		return retVal;
	}

	
		INLINE float getShadowPoint( Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, 
									 float3 posVS, float3 lightPos, float4 invShadowMapSize, float2 invDepthRange
									 PASSBUF_ARG_DECL )
		{
	
		//Point lights
		float3 cubemapDir = posVS.xyz - lightPos.xyz;
		float fDepth = length( cubemapDir );
		cubemapDir *= 1.0 / fDepth;
		cubemapDir = mul( cubemapDir.xyz, passBuf.invViewMatCubemap );
		fDepth = (fDepth - invDepthRange.x) * invDepthRange.y;

		SH_HALF2 uv;
		uv.x = (cubemapDir.x / (1.0 + abs( cubemapDir.z ))) * 0.25 +
				(cubemapDir.z < 0.0 ? SH_HALF( 0.75 ) : SH_HALF( 0.25 ));
		uv.y = (cubemapDir.y / (1.0 + abs( cubemapDir.z ))) * 0.5 + 0.5;

			
	
		float retVal = 0;

		
			SH_HALF2 offsets[9] =
                        
            {
            						
				SH_HALF2( 0, 0 ),	//0, 0
				SH_HALF2( 1, 0 ),	//1, 0
				SH_HALF2( 1, 0 ),	//2, 0

				SH_HALF2(-2, 1 ),	//0, 1
				SH_HALF2( 1, 0 ),	//1, 1
				SH_HALF2( 1, 0 ),	//2, 1

				SH_HALF2(-2, 1 ),	//0, 2
				SH_HALF2( 1, 0 ),	//1, 2
				SH_HALF2( 1, 0 )	//2, 2
			                        
			};
            		
		
		
			
				uv += offsets[0] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[1] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[2] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[3] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[4] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[5] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[6] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[7] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[8] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );		
		
			retVal *= 0.11111111111111;
			///! exponential_shadow_maps
	   ///! exponential_shadow_maps

	
	
		return retVal;
	}

	
		INLINE float getShadowPoint( Texture2D<float> shadowMap, SamplerComparisonState shadowSampler, 
									 float3 posVS, float3 lightPos, float4 invShadowMapSize, float2 invDepthRange,
									 SH_HALF2 minUV, SH_HALF2 maxUV, SH_HALF2 lengthUV
									 PASSBUF_ARG_DECL )
		{
	
		//Point lights
		float3 cubemapDir = posVS.xyz - lightPos.xyz;
		float fDepth = length( cubemapDir );
		cubemapDir *= 1.0 / fDepth;
		cubemapDir = mul( cubemapDir.xyz, passBuf.invViewMatCubemap );
		fDepth = (fDepth - invDepthRange.x) * invDepthRange.y;

		SH_HALF2 uv;
		uv.x = (cubemapDir.x / (1.0 + abs( cubemapDir.z ))) * 0.25 +
				(cubemapDir.z < 0.0 ? SH_HALF( 0.75 ) : SH_HALF( 0.25 ));
		uv.y = (cubemapDir.y / (1.0 + abs( cubemapDir.z ))) * 0.5 + 0.5;

		uv.xy = uv.xy * lengthUV.xy + minUV.xy;	
	
		float retVal = 0;

		
			SH_HALF2 offsets[9] =
                        
            {
            						
				SH_HALF2( 0, 0 ),	//0, 0
				SH_HALF2( 1, 0 ),	//1, 0
				SH_HALF2( 1, 0 ),	//2, 0

				SH_HALF2(-2, 1 ),	//0, 1
				SH_HALF2( 1, 0 ),	//1, 1
				SH_HALF2( 1, 0 ),	//2, 1

				SH_HALF2(-2, 1 ),	//0, 2
				SH_HALF2( 1, 0 ),	//1, 2
				SH_HALF2( 1, 0 )	//2, 2
			                        
			};
            		
		
		
			
				uv += offsets[0] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[1] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[2] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[3] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[4] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[5] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[6] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[7] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );
				uv += offsets[8] * SH_HALF2( invShadowMapSize.xy );				retVal += OGRE_SAMPLE_SHADOW( shadowMap, shadowSampler, uv, fDepth );		
		
			retVal *= 0.11111111111111;
			///! exponential_shadow_maps
	   ///! exponential_shadow_maps

	
	
		retVal = (uv.x <= minUV.x || uv.x >= maxUV.x ||
				  uv.y <= minUV.y || uv.y >= maxUV.y) ? 1.0 : retVal;
	
		return retVal;
	}



	struct PS_OUTPUT
	{
		
			float4 colour0 : SV_Target0;
		
	};




PS_OUTPUT main( PS_INPUT inPs
, float4 gl_FragCoord : SV_Position

)
{
	PS_OUTPUT outPs;
	

	Material material;
	
	uint diffuseIdx;
	uint normalIdx;
	uint specularIdx;
	uint roughnessIdx;


	
	
	
	

	
	
	
	



float4 diffuseCol;
float3 specularCol;

float ROUGHNESS;
	
	float3 nNormal;
	

	
		uint materialId	= worldMaterialIdx[inPs.drawId].x & 0x1FFu;
		material = materialArray[materialId];
	
	diffuseIdx			= material.indices0_3.x & 0x0000FFFFu;
	normalIdx			= material.indices0_3.x >> 16u;
	specularIdx			= material.indices0_3.y & 0x0000FFFFu;
	roughnessIdx		= material.indices0_3.y >> 16u;












	

	



	/// Sample detail maps and weight them against the weight map in the next foreach loop.



		diffuseCol = textureMaps[0].Sample(
													samplerState0,
													float3( UV_DIFFUSE( inPs.uv0.xy ),
															diffuseIdx ) );
		
	

	/// 'insertpiece( SampleDiffuseMap )' must've written to diffuseCol. However if there are no
	/// diffuse maps, we must initialize it to some value.
	

	/// Blend the detail diffuse maps with the main diffuse.
	

		/// Apply the material's diffuse over the textures
		
			diffuseCol.xyz *= material.kD.xyz;
		

	



	
		//Normal mapping.
		float3 geomNormal = normalize( inPs.normal ) ;
		float3 vTangent = normalize( inPs.tangent );

		//Get the TBN matrix
		float3 vBinormal	= normalize( cross( geomNormal, vTangent ) * inPs.biNormalReflection );
		float3x3 TBN		= float3x3( vTangent, vBinormal, geomNormal );

		nNormal = getTSNormal( float3( UV_NORMAL( inPs.uv0.xy ),
																  normalIdx ) );
		
	

	/// If there is no normal map, the first iteration must
	/// initialize nNormal instead of try to merge with it.
	
		
		
	

		/// Blend the detail normal maps with the main normal.
	
	

	
		nNormal = normalize( mul( nNormal, TBN ) );
	

	

		float fShadow = 1.0;
	
		float fShadowBlend = 1.0;
		
		if( inPs.depth <= passBuf.pssmSplitPoints0 )
		{
			fShadow = getShadow( hlms_shadowmap0, shadowSampler, 
								 inPs.posL0,
								 passBuf.shadowRcv[0].invShadowMapSize
								 hlms_shadowmap0_uv_param );
			
				if( inPs.depth > passBuf.pssmBlendPoints0 )
				{
					fShadowBlend = getShadow( hlms_shadowmap1, shadowSampler, 
											  inPs.posL1,
											  passBuf.shadowRcv[1].invShadowMapSize
											  hlms_shadowmap1_uv_param );
					fShadow = lerp( fShadow, fShadowBlend,
									(inPs.depth - passBuf.pssmBlendPoints0) /
									(passBuf.pssmSplitPoints0 - passBuf.pssmBlendPoints0) );
				}
								}
		
		else if( inPs.depth <= passBuf.pssmSplitPoints1 )
		{
			fShadow = getShadow( hlms_shadowmap1, shadowSampler, 
								 inPs.posL1,
								 passBuf.shadowRcv[1].invShadowMapSize
								 hlms_shadowmap1_uv_param );
			
				if( inPs.depth > passBuf.pssmBlendPoints1 )
				{
					fShadowBlend = getShadow( hlms_shadowmap2, shadowSampler, 
											  inPs.posL2,
											  passBuf.shadowRcv[2].invShadowMapSize
											  hlms_shadowmap2_uv_param );
					fShadow = lerp( fShadow, fShadowBlend,
									(inPs.depth - passBuf.pssmBlendPoints1) /
									(passBuf.pssmSplitPoints1 - passBuf.pssmBlendPoints1) );
				}
								}
		else if( inPs.depth <= passBuf.pssmSplitPoints2 )
		{
			fShadow = getShadow( hlms_shadowmap2, shadowSampler, 
								 inPs.posL2,
								 passBuf.shadowRcv[2].invShadowMapSize
								 hlms_shadowmap2_uv_param );
			
				if( inPs.depth > passBuf.pssmFadePoint )
				{
					fShadow = lerp( fShadow, 1.0,
									(inPs.depth - passBuf.pssmFadePoint) /
									(passBuf.pssmSplitPoints2 - passBuf.pssmFadePoint) );
				}
								}	

		ROUGHNESS = material.kS.w * textureMaps[2].Sample(
													samplerState2,
													float3( UV_ROUGHNESS( inPs.uv0.xy ),
															roughnessIdx) ).x;
	ROUGHNESS = max( ROUGHNESS, 0.001f );



		specularCol = textureMaps[0].Sample(
													samplerState0,
													float3( UV_SPECULAR( inPs.uv0.xy ),
															specularIdx) ).xyz * material.kS.xyz;


	//Everything's in Camera space

	float3 viewDir	= normalize( -inPs.pos );
	float NdotV		= saturate( dot( nNormal, viewDir ) );



	float3 finalColour = float3(0, 0, 0);


	



	
		finalColour += BRDF( passBuf.lights[0].position.xyz, viewDir, NdotV, passBuf.lights[0].diffuse, passBuf.lights[0].specular, material, nNormal , diffuseCol.xyz, specularCol.xyz, ROUGHNESS ) * fShadow;





	float3 lightDir;
	float fDistance;
	float3 tmpColour;
	float spotCosAngle;

	//Point lights


	//Spot lights
	//spotParams[0].x = 1.0 / cos( InnerAngle ) - cos( OuterAngle )
	//spotParams[0].y = cos( OuterAngle / 2 )
	//spotParams[0].z = falloff

	lightDir = passBuf.lights[1].position.xyz - inPs.pos;
	fDistance= length( lightDir );
	spotCosAngle = dot( normalize( inPs.pos - passBuf.lights[1].position.xyz ), passBuf.lights[1].spotDirection );

	if( fDistance <= passBuf.lights[1].attenuation.x && spotCosAngle >= passBuf.lights[1].spotParams.y  )
	{
		lightDir *= 1.0 / fDistance;
	
	
		float spotAtten = saturate( (spotCosAngle - passBuf.lights[1].spotParams.y) * passBuf.lights[1].spotParams.x );
		spotAtten = pow( spotAtten, passBuf.lights[1].spotParams.z );
	
		tmpColour = BRDF( lightDir, viewDir, NdotV, passBuf.lights[1].diffuse, passBuf.lights[1].specular, material, nNormal , diffuseCol.xyz, specularCol.xyz, ROUGHNESS )
		* getShadow( hlms_shadowmap3, shadowSampler, 
					 inPs.posL3,
					 passBuf.shadowRcv[3].invShadowMapSize
					 hlms_shadowmap3_uv_param )
	;
		float atten = 1.0 / (0.5 + (passBuf.lights[1].attenuation.y + passBuf.lights[1].attenuation.z * fDistance) * fDistance );
		finalColour += tmpColour * (atten * spotAtten);
	}
	lightDir = passBuf.lights[2].position.xyz - inPs.pos;
	fDistance= length( lightDir );
	spotCosAngle = dot( normalize( inPs.pos - passBuf.lights[2].position.xyz ), passBuf.lights[2].spotDirection );

	if( fDistance <= passBuf.lights[2].attenuation.x && spotCosAngle >= passBuf.lights[2].spotParams.y  )
	{
		lightDir *= 1.0 / fDistance;
	
	
		float spotAtten = saturate( (spotCosAngle - passBuf.lights[2].spotParams.y) * passBuf.lights[2].spotParams.x );
		spotAtten = pow( spotAtten, passBuf.lights[2].spotParams.z );
	
		tmpColour = BRDF( lightDir, viewDir, NdotV, passBuf.lights[2].diffuse, passBuf.lights[2].specular, material, nNormal , diffuseCol.xyz, specularCol.xyz, ROUGHNESS )
		* getShadow( hlms_shadowmap4, shadowSampler, 
					 inPs.posL4,
					 passBuf.shadowRcv[4].invShadowMapSize
					 hlms_shadowmap4_uv_param )
	;
		float atten = 1.0 / (0.5 + (passBuf.lights[2].attenuation.y + passBuf.lights[2].attenuation.z * fDistance) * fDistance );
		finalColour += tmpColour * (atten * spotAtten);
	}


	
		#define FWDPLUS_APPLY_OFFSET_Y(v) (v)
		#define FWDPLUS_APPLY_OFFSET_X(v) (v)
	

	
	
		float f3dMinDistance	= passBuf.f3dData.x;
		float f3dInvMaxDistance	= passBuf.f3dData.y;
		float f3dNumSlicesSub1	= passBuf.f3dData.z;
		uint cellsPerTableOnGrid0= asuint( passBuf.f3dData.w );

		// See C++'s Forward3D::getSliceAtDepth
		/*float fSlice = 1.0 - clamp( (-inPs.pos.z + f3dMinDistance) * f3dInvMaxDistance, 0.0, 1.0 );
		fSlice = (fSlice * fSlice) * (fSlice * fSlice);
		fSlice = (fSlice * fSlice);
		fSlice = floor( (1.0 - fSlice) * f3dNumSlicesSub1 );*/
		float fSlice = clamp( (-inPs.pos.z + f3dMinDistance) * f3dInvMaxDistance, 0.0, 1.0 );
		fSlice = floor( fSlice * f3dNumSlicesSub1 );
		uint slice = uint( fSlice );

		//TODO: Profile performance: derive this mathematically or use a lookup table?
		uint offset = cellsPerTableOnGrid0 * (((1u << (slice << 1u)) - 1u) / 3u);

		float lightsPerCell = passBuf.f3dGridHWW[0].w;
		float windowHeight = passBuf.f3dGridHWW[1].w; //renderTarget->height

		

		//passBuf.f3dGridHWW[slice].x = grid_width / renderTarget->width;
		//passBuf.f3dGridHWW[slice].y = grid_height / renderTarget->height;
		//passBuf.f3dGridHWW[slice].z = grid_width * lightsPerCell;
		//uint sampleOffset = 0;
		uint sampleOffset = offset +
							uint(floor( (windowHeight - FWDPLUS_APPLY_OFFSET_Y(gl_FragCoord.y) ) *
										passBuf.f3dGridHWW[slice].y ) * passBuf.f3dGridHWW[slice].z) +
							uint(floor( FWDPLUS_APPLY_OFFSET_X(gl_FragCoord.x) *
										passBuf.f3dGridHWW[slice].x ) * lightsPerCell);
	

	uint numLightsInGrid = f3dGrid.Load( int(sampleOffset) ).x;

	

	for( uint i=0u; i<numLightsInGrid; ++i )
	{
		//Get the light index
		uint idx = f3dGrid.Load( int(sampleOffset + i + 3u) ).x;

		//Get the light
		float4 posAndType = f3dLightList.Load( int(idx) );

	
		float3 lightDiffuse	= f3dLightList.Load( int(idx + 1u) ).xyz;
	
		float3 lightSpecular= f3dLightList.Load( int(idx + 2u) ).xyz;
		float4 attenuation	= f3dLightList.Load( int(idx + 3u) ).xyzw;

		float3 lightDir	= posAndType.xyz - inPs.pos;
		float fDistance	= length( lightDir );

		[branch]if( fDistance <= attenuation.x  )
		{
			lightDir *= 1.0 / fDistance;
			float atten = 1.0 / (0.5 + (attenuation.y + attenuation.z * fDistance) * fDistance );
			
				atten *= max( (attenuation.x - fDistance) * attenuation.w, 0.0f );
			

			//Point light
			float3 tmpColour = BRDF( lightDir, viewDir, NdotV, lightDiffuse.xyz, lightSpecular, material, nNormal , diffuseCol.xyz, specularCol.xyz, ROUGHNESS );
			finalColour += tmpColour * atten;
		}
	}

	uint prevLightCount = numLightsInGrid;
	numLightsInGrid		= f3dGrid.Load( int(sampleOffset + 1u) ).x;

	

	for( uint i=prevLightCount; i<numLightsInGrid; ++i )
	{
		//Get the light index
		uint idx = f3dGrid.Load( int(sampleOffset + i + 3u) ).x;

		//Get the light
		float4 posAndType = f3dLightList.Load( int(idx) );

	
		float3 lightDiffuse	= f3dLightList.Load( int(idx + 1u) ).xyz;
	
		float3 lightSpecular= f3dLightList.Load( int(idx + 2u) ).xyz;
		float4 attenuation	= f3dLightList.Load( int(idx + 3u) ).xyzw;
		float3 spotDirection= f3dLightList.Load( int(idx + 4u) ).xyz;
		float3 spotParams	= f3dLightList.Load( int(idx + 5u) ).xyz;

		float3 lightDir	= posAndType.xyz - inPs.pos;
		float fDistance	= length( lightDir );

		[branch]if( fDistance <= attenuation.x  )
		{
			lightDir *= 1.0 / fDistance;
			float atten = 1.0 / (0.5 + (attenuation.y + attenuation.z * fDistance) * fDistance );
			
				atten *= max( (attenuation.x - fDistance) * attenuation.w, 0.0f );
			

			//spotParams.x = 1.0 / cos( InnerAngle ) - cos( OuterAngle )
			//spotParams.y = cos( OuterAngle / 2 )
			//spotParams.z = falloff

			//Spot light
			float spotCosAngle = dot( normalize( inPs.pos - posAndType.xyz ), spotDirection.xyz );

			float spotAtten = clamp( (spotCosAngle - spotParams.y) * spotParams.x, 0.0, 1.0 );
			spotAtten = pow( spotAtten, spotParams.z );
			atten *= spotAtten;

			if( spotCosAngle >= spotParams.y )
			{
				float3 tmpColour = BRDF( lightDir, viewDir, NdotV, lightDiffuse.xyz, lightSpecular, material, nNormal , diffuseCol.xyz, specularCol.xyz, ROUGHNESS );
				finalColour += tmpColour * atten;
			}
		}
	}



	






	float3 reflDir = 2.0 * dot( viewDir, nNormal ) * nNormal - viewDir;
	
	

	

	

	
		float ambientWD = dot( passBuf.ambientHemisphereDir.xyz, nNormal ) * 0.5 + 0.5;
		float ambientWS = dot( passBuf.ambientHemisphereDir.xyz, reflDir ) * 0.5 + 0.5;

		
			float3 envColourS = lerp( passBuf.ambientLowerHemi.xyz, passBuf.ambientUpperHemi.xyz, ambientWD );
			float3 envColourD = lerp( passBuf.ambientLowerHemi.xyz, passBuf.ambientUpperHemi.xyz, ambientWS );
		
	

	
	float NdotL = saturate( dot( nNormal, reflDir ) );
	float VdotH = saturate( dot( viewDir, normalize( reflDir + viewDir ) ) );
	float fresnelS = material.F0.x + pow( 1.0 - VdotH, 5.0 ) * (max( 1.0 - ROUGHNESS, material.F0.x ) - material.F0.x);

	
		float fresnelD = 1.0f - fresnelS;

	finalColour += envColourD * diffuseCol.xyz * fresnelD +
					envColourS * specularCol.xyz * fresnelS;


///!hlms_prepass


	
		outPs.colour0.xyz	= finalColour;
	

	
		outPs.colour0.w		= 1.0;

	

	


	

	


	return outPs;

}



