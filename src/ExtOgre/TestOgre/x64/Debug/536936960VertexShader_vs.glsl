#if 0
	***	hlms_shadowmap4_uv_min_x_int	0
	***	hlms_uv_count0	2
	***	uv_emissive	0
	***	first_valid_detail_map_nm	4
	***	fresnel_scalar	0
	***	hlms_shadowmap4_uv_max_y_int	1
	***	hlms_uv_count	1
	***	pcf_iterations	9
	***	hlms_shadowmap4_uv_max_y_fract	0
	***	uv_detail_nm1	0
	***	hlms_lights_spotparams	2
	***	hlms_forwardplus_debug	0
	***	uv_detail_nm2	0
	***	BRDF_Default	1
	***	hlms_shadowmap2_array_idx	0
	***	hlms_shadowmap3_uv_max_x_fract	0
	***	uv_specular	0
	***	hlms_shadowmap1_uv_min_x_fract	0
	***	PsoBlendblock	0
	***	hlms_shadowmap2_uv_min_x_fract	50000
	***	hlms_forwardplus_flipY	1
	***	forward_clustered	599612461
	***	glsl	635204550
	***	hlms_shadowmap2_uv_max_y_fract	42857
	***	hlms_shadowmap0_uv_max_x_fract	0
	***	hlms_shadowmap2_uv_max_y_int	0
	***	hlms_high_quality	0
	***	hlms_num_shadow_map_lights	5
	***	hlms_lights_directional	1
	***	hlms_shadowmap0_uv_min_y_fract	0
	***	PsoMacroblock	0
	***	hlms_shadowmap1_uv_min_y_fract	28571
	***	alpha_test	0
	***	GGX_height_correlated	1
	***	hlms_shadowmap2	0
	***	glsles	1070293233
	***	metallic_workflow	0
	***	hlms_shadowmap4	0
	***	hw_gamma_write	1
	***	hlms_shadowmap0_uv_min_y_int	0
	***	uv_detail_weight	0
	***	roughness_map_idx	2
	***	hlms_shadowmap0_uv_max_x_int	1
	***	pcf_4x4	1
	***	hlms_shadowmap4_array_idx	0
	***	hlms_shadowmap1_uvs_fulltex	1
	***	hlms_shadowmap1_uv_max_y_fract	42857
	***	uv_detail_nm3	0
	***	hlms_shadowmap2_uv_max_x_int	1
	***	hlms_pssm_splits	3
	***	signed_int_textures	1
	***	hlms_shadowmap0_uv_min_x_int	0
	***	hlms_shadowmap0_uv_min_x_fract	0
	***	hlms_lights_spot	3
	***	shadowmap2_is_directional_light	1
	***	GL_ARB_shading_language_420pack	1
	***	hlms_shadowmap3_array_idx	0
	***	uv_normal	0
	***	hlms_alphablend	0
	***	hlms_num_shadow_map_textures	1
	***	hlms_shadowmap1_array_idx	0
	***	hlms_shadowmap4_uvs_fulltex	1
	***	num_textures	3
	***	hlms_shadowmap1_uv_min_x_int	0
	***	normal_map_tex	2
	***	uv_detail3	0
	***	orwardplus_covers_entire_target	1
	***	hlms_shadow_uses_depth_texture	1
	***	normal_map	1
	***	hlms_shadowmap1	0
	***	hlms_shadowmap2_uv_max_x_fract	0
	***	uv_detail1	0
	***	fresnel_workflow	0
	***	hlms_shadowmap2_uv_min_y_fract	28571
	***	shadowmap1_is_directional_light	1
	***	hlms_shadowmap4_uv_max_x_fract	0
	***	forward3d_num_slices	5
	***	hlms_forwardplus	-1972038953
	***	materials_per_buffer	256
	***	hw_gamma_read	1
	***	normal_map_tex_idx	1
	***	hlms_skeleton	0
	***	hlms_shadowmap1_uv_max_y_int	0
	***	hlms_shadowmap3_uv_min_y_int	0
	***	forward3d	-1972038953
	***	hlms_shadowmap2_uv_min_x_int	0
	***	hlms_shadowmap1_uv_max_x_int	0
	***	syntax	635204550
	***	hlms_lights_point	1
	***	hlms_shadowmap3_uv_max_x_int	1
	***	metal	-1698855755
	***	GL_ARB_base_instance	1
	***	s_lights_directional_non_caster	1
	***	hlms_shadowmap4_uv_min_x_fract	0
	***	uv_detail0	0
	***	uv_diffuse	0
	***	diffuse_map	1
	***	hlms_pssm_blend	1
	***	uv_detail_nm0	0
	***	hlms_shadowmap3_uv_max_y_int	0
	***	hlms_shadowmap4_uv_min_y_int	0
	***	specular_map	1
	***	GL3+	330
	***	diffuse_map_idx	0
	***	hlms_lights_attenuation	2
	***	hlms_shadowmap4_uv_min_y_fract	71428
	***	shadowmap0_is_directional_light	1
	***	hlms_shadowmap4_uv_max_x_int	1
	***	hlms_shadowmap0_array_idx	0
	***	hlms_render_depth_only	0
	***	hlms_shadowmap3_uv_min_x_fract	0
	***	uv_detail2	0
	***	hlms_shadowmap3_uv_min_x_int	0
	***	hlms_shadowmap1_uv_max_x_fract	50000
	***	hlms_shadowmap0_uvs_fulltex	1
	***	hlms_qtangent	1
	***	hlms_shadowmap1_uv_min_y_int	0
	***	uv_roughness	0
	***	hlms_shadowmap3_uvs_fulltex	1
	***	roughness_map	3
	***	receive_shadows	1
	***	hlms_shadowmap3_uv_min_y_fract	42857
	***	hlms_pssm_fade	1
	***	_forward_fade_attenuation_range	1
	***	hlms_shadowmap0	0
	***	hlms_shadowmap3	0
	***	hlms_shadowmap2_uvs_fulltex	1
	***	hlms_shadowmap2_uv_min_y_int	0
	***	specular_map_idx	0
	***	ambient_hemisphere	1
	***	hlms_shadowmap0_uv_max_y_fract	28571
	***	hlsl	-334286542
	***	hlms_shadowmap0_uv_max_y_int	0
	***	hlms_shadowmap3_uv_max_y_fract	71428
	***	normal_weight	0
	***	GL_ARB_texture_buffer_range	1
	***	hlms_vpos	1
	DONE DUMPING PROPERTIES
	DONE DUMPING PIECES
#endif


#version 330 core


    #extension GL_ARB_shading_language_420pack: require
    #define layout_constbuffer(x) layout( std140, x )

    #define bufferFetch texelFetch

#define float2 vec2
#define float3 vec3
#define float4 vec4

#define int2 ivec2
#define int3 ivec3
#define int4 ivec4

#define uint2 uvec2
#define uint3 uvec3
#define uint4 uvec4

#define float3x3 mat3
#define float4x4 mat4

#define mul( x, y ) ((x) * (y))
#define saturate(x) clamp( (x), 0.0, 1.0 )
#define lerp mix
#define INLINE

#define outVs_Position gl_Position
#define OGRE_SampleLevel( tex, sampler, uv, lod ) textureLod( tex, uv.xy, lod )



out gl_PerVertex
{
	vec4 gl_Position;

};

layout(std140) uniform;


mat4 UNPACK_MAT4( samplerBuffer matrixBuf, uint pixelIdx )
{
	vec4 row0 = texelFetch( matrixBuf, int((pixelIdx) << 2u) );
	vec4 row1 = texelFetch( matrixBuf, int(((pixelIdx) << 2u) + 1u) );
	vec4 row2 = texelFetch( matrixBuf, int(((pixelIdx) << 2u) + 2u) );
	vec4 row3 = texelFetch( matrixBuf, int(((pixelIdx) << 2u) + 3u) );
    return mat4( row0, row1, row2, row3 );
}


mat3x4 UNPACK_MAT3x4( samplerBuffer matrixBuf, uint pixelIdx )
{
	vec4 row0 = texelFetch( matrixBuf, int((pixelIdx) << 2u) );
	vec4 row1 = texelFetch( matrixBuf, int(((pixelIdx) << 2u) + 1u) );
	vec4 row2 = texelFetch( matrixBuf, int(((pixelIdx) << 2u) + 2u) );
	return mat3x4( row0, row1, row2 );
}


in vec4 vertex;


in vec4 qtangent;






in vec2 uv0;


	in uint drawId;





out block
{

    
		
			flat uint drawId;
				
			vec3 pos;
			vec3 normal;
			vec3 tangent;
				flat float biNormalReflection;							
			vec2 uv0;
		
			
				vec4 posL0;
			
				vec4 posL1;
			
				vec4 posL2;
			
				vec4 posL3;
			
				vec4 posL4;		float depth;					

} outVs;


// START UNIFORM DECLARATION

struct ShadowReceiverData
{
    mat4 texViewProj;
	vec2 shadowDepthRange;
	vec4 invShadowMapSize;
};

struct Light
{
	vec4 position; //.w contains the objLightMask
	vec3 diffuse;
	vec3 specular;

	vec3 attenuation;
	vec3 spotDirection;
	vec3 spotParams;
};



//Uniforms that change per pass
layout_constbuffer(binding = 0) uniform PassBuffer
{
	//Vertex shader (common to both receiver and casters)
	mat4 viewProj;




	//Vertex shader
	mat4 view;
	ShadowReceiverData shadowRcv[5];
	//-------------------------------------------------------------------------

	//Pixel shader
	mat3 invViewMatCubemap;




	vec4 ambientUpperHemi;

	vec4 ambientLowerHemi;
	vec4 ambientHemisphereDir;



	float pssmSplitPoints0;
	float pssmSplitPoints1;
	float pssmSplitPoints2;
	float pssmBlendPoints0;
	float pssmBlendPoints1;
	float pssmFadePoint;	Light lights[3];

	//Forward3D
	//f3dData.x = minDistance;
	//f3dData.y = invMaxDistance;
	//f3dData.z = f3dNumSlicesSub1;
	//f3dData.w = uint cellsPerTableOnGrid0 (floatBitsToUint);

	//Clustered Forward:
	//f3dData.x = minDistance;
	//f3dData.y = invExponentK;
	//f3dData.z = f3dNumSlicesSub1;
	//f3dData.w = renderWindow->getHeight();
	vec4 f3dData;
	
		vec4 f3dGridHWW[5];
		vec4 f3dViewportOffset;
		
	


	
} passBuf;


/*layout(binding = 0) */uniform samplerBuffer worldMatBuf;


// END UNIFORM DECLARATION



vec3 xAxis( vec4 qQuat )
{
	float fTy  = 2.0 * qQuat.y;
	float fTz  = 2.0 * qQuat.z;
	float fTwy = fTy * qQuat.w;
	float fTwz = fTz * qQuat.w;
	float fTxy = fTy * qQuat.x;
	float fTxz = fTz * qQuat.x;
	float fTyy = fTy * qQuat.y;
	float fTzz = fTz * qQuat.z;

	return vec3( 1.0-(fTyy+fTzz), fTxy+fTwz, fTxz-fTwy );
}



vec3 yAxis( vec4 qQuat )
{
	float fTx  = 2.0 * qQuat.x;
	float fTy  = 2.0 * qQuat.y;
	float fTz  = 2.0 * qQuat.z;
	float fTwx = fTx * qQuat.w;
	float fTwz = fTz * qQuat.w;
	float fTxx = fTx * qQuat.x;
	float fTxy = fTy * qQuat.x;
	float fTyz = fTz * qQuat.y;
	float fTzz = fTz * qQuat.z;

	return vec3( fTxy-fTwz, 1.0-(fTxx+fTzz), fTyz+fTwx );
}










//SkeletonTransform // !hlms_skeleton


    






void main()
{


    
    

    
    mat3x4 worldMat = UNPACK_MAT3x4( worldMatBuf, drawId << 1u);
	
	mat4 worldView = UNPACK_MAT4( worldMatBuf, (drawId << 1u) + 1u );
	
    
	vec4 worldPos = vec4( (vertex * worldMat).xyz, 1.0f );



	//Decode qTangent to TBN with reflection
	vec3 normal		= xAxis( normalize( qtangent ) );
	
	vec3 tangent	= yAxis( qtangent );
	outVs.biNormalReflection = sign( qtangent.w ); //We ensure in C++ qtangent.w is never 0
	


	
	
	//Lighting is in view space
	outVs.pos		= (vertex * worldView).xyz;
	outVs.normal	= normal * mat3(worldView);
	outVs.tangent	= tangent * mat3(worldView);

	gl_Position = worldPos * passBuf.viewProj;



	
		
			
				outVs.posL0 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[0].texViewProj );
			
				outVs.posL1 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[1].texViewProj );
			
				outVs.posL2 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[2].texViewProj );
			
				outVs.posL3 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[3].texViewProj );
			
				outVs.posL4 = mul( float4(worldPos.xyz, 1.0f), passBuf.shadowRcv[4].texViewProj );
		
			
								outVs.posL0.z = (outVs.posL0.z * 0.5) + 0.5;					
			
								outVs.posL1.z = (outVs.posL1.z * 0.5) + 0.5;					
			
								outVs.posL2.z = (outVs.posL2.z * 0.5) + 0.5;					
			
				
					outVs.posL3.z = outVs.posL3.z * passBuf.shadowRcv[3].shadowDepthRange.y;
								outVs.posL3.z = (outVs.posL3.z * 0.5) + 0.5;					
			
				
					outVs.posL4.z = outVs.posL4.z * passBuf.shadowRcv[4].shadowDepthRange.y;
								outVs.posL4.z = (outVs.posL4.z * 0.5) + 0.5;					
		outVs.depth = outVs_Position.z;	
	

	/// hlms_uv_count will be 0 on shadow caster passes w/out alpha test

	outVs.uv0 = uv0;


	outVs.drawId = drawId;

	



	
}
